name: Build Release from Dispatch

on:
  repository_dispatch:
    types: [build-release]

permissions:
  contents: write

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'
  PNPM_STORE_PATH: ~/.pnpm-store
  APP_DIR: apps/windword-desktop

jobs:
  # ============================================
  # Prepare: 解析 dispatch payload
  # ============================================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.meta.outputs.tag_name }}
      semver: ${{ steps.meta.outputs.semver }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
    steps:
      - name: Parse dispatch payload
        id: meta
        run: |
          set -euxo pipefail
          TAG="${{ github.event.client_payload.tag }}"
          SHA="${{ github.event.client_payload.sha }}"
          SHORT_SHA="${SHA:0:7}"
          SEMVER="${TAG#v}"

          echo "tag_name=${TAG}" >> "$GITHUB_OUTPUT"
          echo "semver=${SEMVER}" >> "$GITHUB_OUTPUT"
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"

          echo "Tag: ${TAG}"
          echo "Semver: ${SEMVER}"
          echo "Short SHA: ${SHORT_SHA}"

  # ============================================
  # macOS ARM64 Build (Apple Silicon)
  # ============================================
  macos-arm64:
    needs: prepare
    runs-on: macos-26
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
      CSC_FOR_PULL_REQUEST: 'true'
      CSC_LINK_BASE64: ${{ secrets.CSC_LINK_BASE64 }}
      CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Configure code signing keychain
        shell: bash
        run: |
          set -euxo pipefail
          if [ -z "${CSC_LINK_BASE64}" ]; then
            echo 'CSC_LINK_BASE64 secret is required for code signing' >&2
            exit 1
          fi
          if [ -z "${CSC_KEY_PASSWORD}" ]; then
            echo 'CSC_KEY_PASSWORD secret is required for code signing' >&2
            exit 1
          fi
          CERT_PATH="$RUNNER_TEMP/windword-developer-id.p12"
          KEYCHAIN_NAME="windword-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"
          echo "::add-mask::${KEYCHAIN_PASSWORD}"
          echo "${CSC_LINK_BASE64}" | base64 --decode > "${CERT_PATH}"
          security delete-keychain "${KEYCHAIN_NAME}" 2>/dev/null || true
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security set-keychain-settings "${KEYCHAIN_NAME}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security import "${CERT_PATH}" -k "${KEYCHAIN_NAME}" -P "${CSC_KEY_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/productsign
          existing_keychains=$(security list-keychains -d user | sed 's/\"//g')
          security list-keychains -d user -s "${KEYCHAIN_NAME}" ${existing_keychains}
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          echo "CSC_LINK=${CERT_PATH}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_NAME=${KEYCHAIN_NAME}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_PASSWORD=${KEYCHAIN_PASSWORD}" >> "${GITHUB_ENV}"

      - name: Inspect code signing identities
        shell: bash
        run: |
          set -euxo pipefail
          security find-identity -v -p codesigning "${KEYCHAIN_NAME}" || true

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install setuptools for node-gyp
        shell: bash
        run: pip3 install setuptools --break-system-packages

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile --config.store-dir=${{ env.PNPM_STORE_PATH }}

      - name: Build Apple Audio Mute CLI
        shell: bash
        run: pnpm build:apple-audio-mute-cli

      - name: Build Apple Audio Device CLI
        shell: bash
        run: pnpm build:apple-audio-device-cli

      - name: Build Apple Selection Detector CLI
        shell: bash
        run: pnpm build:apple-selection-detector-cli

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Verify notarization environment
        shell: bash
        run: |
          set -euo pipefail
          missing=0
          for var in APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID; do
            if [ -z "${!var:-}" ]; then
              echo "::error::${var} is empty"
              missing=1
            else
              echo "${var} is set"
            fi
          done
          if [ "$missing" -ne 0 ]; then exit 1; fi

      - name: Package artifacts
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: 'true'
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --mac zip --arm64
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          zip=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.zip' ! -name '*.blockmap' -print -quit || true)
          if [ -z "$zip" ]; then
            echo 'No zip artifact produced by electron-builder' >&2
            exit 1
          fi
          cp "$zip" "release/$(basename "$zip")"
          # Include metadata files
          METADATA_FILE=$(find "$APP_DIST" -maxdepth 1 -type f -name 'latest-mac*.yml' -print -quit || true)
          if [ -n "$METADATA_FILE" ]; then
            cp "$METADATA_FILE" "release/$(basename "$METADATA_FILE")"
          fi
          find "$APP_DIST" -maxdepth 1 -type f -name '*.blockmap' -exec cp {} release/ \;

      - name: Validate notarization
        shell: bash
        run: |
          set -euxo pipefail
          APP_DIST="${APP_DIR}/dist"
          ARCHIVE=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.zip' ! -name '*.blockmap' -print -quit || true)
          if [ -z "$ARCHIVE" ]; then
            echo 'No zip artifact found to validate' >&2
            exit 1
          fi
          EXTRACT_DIR="$(mktemp -d)"
          ditto -x -k "$ARCHIVE" "$EXTRACT_DIR"
          APP_PATH=$(find "$EXTRACT_DIR" -maxdepth 2 -type d -name '*.app' -print -quit || true)
          if [ -z "$APP_PATH" ]; then
            echo 'Unable to locate .app bundle within archive' >&2
            exit 1
          fi
          xcrun stapler validate "$APP_PATH"
          spctl --assess --type exec -vv "$APP_PATH"

      - name: Upload macOS arm64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-arm64
          path: release

      - name: Clean up signing keychain
        if: always()
        shell: bash
        run: |
          if [ -n "${KEYCHAIN_NAME:-}" ]; then
            security delete-keychain "${KEYCHAIN_NAME}" || true
          fi

  # ============================================
  # macOS x64 Build (Intel)
  # ============================================
  macos-x64:
    needs: prepare
    runs-on: macos-15-intel
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
      CSC_FOR_PULL_REQUEST: 'true'
      CSC_LINK_BASE64: ${{ secrets.CSC_LINK_BASE64 }}
      CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Configure code signing keychain
        shell: bash
        run: |
          set -euxo pipefail
          if [ -z "${CSC_LINK_BASE64}" ]; then
            echo 'CSC_LINK_BASE64 secret is required for code signing' >&2
            exit 1
          fi
          if [ -z "${CSC_KEY_PASSWORD}" ]; then
            echo 'CSC_KEY_PASSWORD secret is required for code signing' >&2
            exit 1
          fi
          CERT_PATH="$RUNNER_TEMP/windword-developer-id.p12"
          KEYCHAIN_NAME="windword-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"
          echo "::add-mask::${KEYCHAIN_PASSWORD}"
          echo "${CSC_LINK_BASE64}" | base64 --decode > "${CERT_PATH}"
          security delete-keychain "${KEYCHAIN_NAME}" 2>/dev/null || true
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security set-keychain-settings "${KEYCHAIN_NAME}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security import "${CERT_PATH}" -k "${KEYCHAIN_NAME}" -P "${CSC_KEY_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/productsign
          existing_keychains=$(security list-keychains -d user | sed 's/\"//g')
          security list-keychains -d user -s "${KEYCHAIN_NAME}" ${existing_keychains}
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          echo "CSC_LINK=${CERT_PATH}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_NAME=${KEYCHAIN_NAME}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_PASSWORD=${KEYCHAIN_PASSWORD}" >> "${GITHUB_ENV}"

      - name: Inspect code signing identities
        shell: bash
        run: |
          set -euxo pipefail
          security find-identity -v -p codesigning "${KEYCHAIN_NAME}" || true

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install setuptools for node-gyp
        shell: bash
        run: pip3 install setuptools --break-system-packages

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile --config.store-dir=${{ env.PNPM_STORE_PATH }}

      - name: Build Apple Audio Mute CLI
        shell: bash
        run: pnpm build:apple-audio-mute-cli

      - name: Build Apple Audio Device CLI
        shell: bash
        run: pnpm build:apple-audio-device-cli

      - name: Build Apple Selection Detector CLI
        shell: bash
        run: pnpm build:apple-selection-detector-cli

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Verify notarization environment
        shell: bash
        run: |
          set -euo pipefail
          missing=0
          for var in APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID; do
            if [ -z "${!var:-}" ]; then
              echo "::error::${var} is empty"
              missing=1
            else
              echo "${var} is set"
            fi
          done
          if [ "$missing" -ne 0 ]; then exit 1; fi

      - name: Package artifacts
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: 'true'
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --mac zip --x64
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          zip=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.zip' ! -name '*.blockmap' -print -quit || true)
          if [ -z "$zip" ]; then
            echo 'No zip artifact produced by electron-builder' >&2
            exit 1
          fi
          cp "$zip" "release/$(basename "$zip")"
          # Include metadata files
          METADATA_FILE=$(find "$APP_DIST" -maxdepth 1 -type f -name 'latest-mac*.yml' -print -quit || true)
          if [ -n "$METADATA_FILE" ]; then
            cp "$METADATA_FILE" "release/$(basename "$METADATA_FILE")"
          fi
          find "$APP_DIST" -maxdepth 1 -type f -name '*.blockmap' -exec cp {} release/ \;

      - name: Validate notarization
        shell: bash
        run: |
          set -euxo pipefail
          APP_DIST="${APP_DIR}/dist"
          ARCHIVE=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.zip' ! -name '*.blockmap' -print -quit || true)
          if [ -z "$ARCHIVE" ]; then
            echo 'No zip artifact found to validate' >&2
            exit 1
          fi
          EXTRACT_DIR="$(mktemp -d)"
          ditto -x -k "$ARCHIVE" "$EXTRACT_DIR"
          APP_PATH=$(find "$EXTRACT_DIR" -maxdepth 2 -type d -name '*.app' -print -quit || true)
          if [ -z "$APP_PATH" ]; then
            echo 'Unable to locate .app bundle within archive' >&2
            exit 1
          fi
          xcrun stapler validate "$APP_PATH"
          spctl --assess --type exec -vv "$APP_PATH"

      - name: Upload macOS x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-x64
          path: release

      - name: Clean up signing keychain
        if: always()
        shell: bash
        run: |
          if [ -n "${KEYCHAIN_NAME:-}" ]; then
            security delete-keychain "${KEYCHAIN_NAME}" || true
          fi

  # ============================================
  # Windows x64 Build
  # ============================================
  windows-x64:
    needs: prepare
    runs-on: windows-latest
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile --config.store-dir=${{ env.PNPM_STORE_PATH }}

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Package artifacts
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --win nsis --x64
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          installer=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.exe' -print -quit || true)
          if [ -z "$installer" ]; then
            echo 'No Windows installer produced by electron-builder' >&2
            exit 1
          fi
          cp "$installer" "release/$(basename "$installer")"
          # Include metadata files
          METADATA_FILE=$(find "$APP_DIST" -maxdepth 1 -type f -name 'latest.yml' -print -quit || true)
          if [ -n "$METADATA_FILE" ]; then
            cp "$METADATA_FILE" "release/$(basename "$METADATA_FILE")"
          fi
          find "$APP_DIST" -maxdepth 1 -type f -name '*.blockmap' -exec cp {} release/ \;

      - name: Upload Windows x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-x64
          path: release

  # ============================================
  # Create Release: 创建 GitHub Release
  # ============================================
  create-release:
    needs:
      - prepare
      - macos-arm64
      - macos-x64
      - windows-x64
    runs-on: ubuntu-latest
    env:
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        id: assets
        shell: bash
        run: |
          set -euxo pipefail
          assets_file="release-assets.txt"
          find artifacts -type f \( \
            -name '*.zip' -o \
            -name '*.dmg' -o \
            -name '*.exe' -o \
            -name '*.yml' -o \
            -name '*.blockmap' \
          \) -print | sort > "$assets_file"

          if [ ! -s "$assets_file" ]; then
            echo 'No eligible release assets were found' >&2
            exit 1
          fi

          cat "$assets_file"
          echo "assets_file=$assets_file" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        shell: bash
        run: |
          set -euxo pipefail
          RELEASE_TIME="$(date -u '+%Y-%m-%d %H:%M:%SZ')"
          cat > release-notes.md << EOF
          ## WindWord ${TAG_NAME}

          Released at: ${RELEASE_TIME}

          ### Downloads

          | Platform | Download |
          |----------|----------|
          | macOS (Apple Silicon) | ✅ |
          | macOS (Intel) | ✅ |
          | Windows (x64) | ✅ |
          EOF

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ASSETS_FILE: ${{ steps.assets.outputs.assets_file }}
        shell: bash
        run: |
          set -euxo pipefail

          assets=()
          while IFS= read -r asset; do
            assets+=("$asset")
          done < "${ASSETS_FILE}"

          # Delete existing release if exists
          if gh release view "${TAG_NAME}" >/dev/null 2>&1; then
            gh release delete "${TAG_NAME}" -y || true
          fi

          # Create new release
          gh release create "${TAG_NAME}" "${assets[@]}" \
            --title "WindWord ${TAG_NAME}" \
            --notes-file release-notes.md

  # ============================================
  # Upload to CDN: 上传到云存储
  # ============================================
  upload-to-cdn:
    needs:
      - prepare
      - create-release
    runs-on: ubuntu-latest
    env:
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Download release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          mkdir -p artifacts
          gh release download "$TAG_NAME" -D artifacts
          echo "Downloaded assets:"
          ls -la artifacts/

      - name: Install AWS CLI
        run: pip install awscli

      - name: Upload to Qiniu
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.QINIU_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.QINIU_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.QINIU_REGION }}
          QINIU_ENDPOINT: ${{ secrets.QINIU_ENDPOINT }}
          QINIU_BUCKET: ${{ secrets.QINIU_BUCKET }}
          QINIU_PREFIX: ${{ secrets.QINIU_PREFIX }}
        run: |
          set -euxo pipefail
          PREFIX="${QINIU_PREFIX:-releases}"
          DEST="s3://${QINIU_BUCKET}/${PREFIX}/${TAG_NAME}"
          echo "Uploading to Qiniu: ${DEST}"
          aws s3 sync artifacts "$DEST" --endpoint-url "$QINIU_ENDPOINT"
          echo "Qiniu upload completed successfully"

      - name: Upload to Cloudflare R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
          R2_PREFIX: ${{ secrets.R2_PREFIX }}
        run: |
          set -euxo pipefail
          PREFIX="${R2_PREFIX:-releases}"
          DEST="s3://${R2_BUCKET}/${PREFIX}/${TAG_NAME}"
          echo "Uploading to Cloudflare R2: ${DEST}"
          aws s3 sync artifacts "$DEST" --endpoint-url "$R2_ENDPOINT"
          echo "Cloudflare R2 upload completed successfully"

  # ============================================
  # Cleanup: 清理 artifacts
  # ============================================
  cleanup:
    needs:
      - create-release
      - upload-to-cdn
    if: always() && needs.create-release.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Clean up artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euxo pipefail
          echo "Cleaning up artifacts from this run..."
          for id in $(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id'); do
            echo "Deleting artifact $id..."
            gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$id || true
          done
          echo "Artifacts cleaned up"
