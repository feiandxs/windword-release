name: Build Release from Dispatch

on:
  repository_dispatch:
    types: [build-release]

permissions:
  contents: write

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'
  PNPM_STORE_PATH: ~/.pnpm-store
  APP_DIR: apps/windword-desktop

jobs:
  # ============================================
  # Prepare: 解析 dispatch payload
  # ============================================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.meta.outputs.tag_name }}
      semver: ${{ steps.meta.outputs.semver }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
    steps:
      - name: Parse dispatch payload
        id: meta
        run: |
          set -euxo pipefail
          TAG="${{ github.event.client_payload.tag }}"
          SHA="${{ github.event.client_payload.sha }}"
          SHORT_SHA="${SHA:0:7}"
          SEMVER="${TAG#v}"

          echo "tag_name=${TAG}" >> "$GITHUB_OUTPUT"
          echo "semver=${SEMVER}" >> "$GITHUB_OUTPUT"
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"

          echo "Tag: ${TAG}"
          echo "Semver: ${SEMVER}"
          echo "Short SHA: ${SHORT_SHA}"

  # ============================================
  # macOS ARM64 Build (Apple Silicon)
  # ============================================
  macos-arm64:
    needs: prepare
    runs-on: macos-26
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
      CSC_FOR_PULL_REQUEST: 'true'
      CSC_LINK_BASE64: ${{ secrets.CSC_LINK_BASE64 }}
      CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Configure code signing keychain
        shell: bash
        run: |
          set -euxo pipefail
          if [ -z "${CSC_LINK_BASE64}" ]; then
            echo 'CSC_LINK_BASE64 secret is required for code signing' >&2
            exit 1
          fi
          if [ -z "${CSC_KEY_PASSWORD}" ]; then
            echo 'CSC_KEY_PASSWORD secret is required for code signing' >&2
            exit 1
          fi
          CERT_PATH="$RUNNER_TEMP/windword-developer-id.p12"
          KEYCHAIN_NAME="windword-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"
          echo "::add-mask::${KEYCHAIN_PASSWORD}"
          echo "${CSC_LINK_BASE64}" | base64 --decode > "${CERT_PATH}"
          security delete-keychain "${KEYCHAIN_NAME}" 2>/dev/null || true
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security set-keychain-settings "${KEYCHAIN_NAME}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security import "${CERT_PATH}" -k "${KEYCHAIN_NAME}" -P "${CSC_KEY_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/productsign
          existing_keychains=$(security list-keychains -d user | sed 's/\"//g')
          security list-keychains -d user -s "${KEYCHAIN_NAME}" ${existing_keychains}
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          echo "CSC_LINK=${CERT_PATH}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_NAME=${KEYCHAIN_NAME}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_PASSWORD=${KEYCHAIN_PASSWORD}" >> "${GITHUB_ENV}"

      - name: Inspect code signing identities
        shell: bash
        run: |
          set -euxo pipefail
          security find-identity -v -p codesigning "${KEYCHAIN_NAME}" || true

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install setuptools for node-gyp
        shell: bash
        run: pip3 install setuptools --break-system-packages

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile --config.store-dir=${{ env.PNPM_STORE_PATH }}

      - name: Build Apple Audio Mute CLI
        shell: bash
        run: pnpm build:apple-audio-mute-cli

      - name: Build Apple Audio Device CLI
        shell: bash
        run: pnpm build:apple-audio-device-cli

      - name: Build Apple Selection Detector CLI
        shell: bash
        run: pnpm build:apple-selection-detector-cli

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Verify notarization environment
        shell: bash
        run: |
          set -euo pipefail
          missing=0
          for var in APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID; do
            if [ -z "${!var:-}" ]; then
              echo "::error::${var} is empty"
              missing=1
            else
              echo "${var} is set"
            fi
          done
          if [ "$missing" -ne 0 ]; then exit 1; fi

      - name: Package artifacts
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: 'true'
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --mac --arm64 --publish never
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          zip=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.zip' ! -name '*.blockmap' -print -quit || true)
          if [ -z "$zip" ]; then
            echo 'No zip artifact produced by electron-builder' >&2
            exit 1
          fi
          cp "$zip" "release/$(basename "$zip")"
          # Include metadata files
          if [ -f "$APP_DIST/latest-mac.yml" ]; then
            cp "$APP_DIST/latest-mac.yml" "release/latest-mac.yml"
          fi
          # Copy DMG and blockmap files
          find "$APP_DIST" -maxdepth 1 -type f -name '*.dmg' -exec cp {} release/ \;
          find "$APP_DIST" -maxdepth 1 -type f -name '*.blockmap' -exec cp {} release/ \;

      - name: Validate notarization
        shell: bash
        run: |
          set -euxo pipefail
          APP_DIST="${APP_DIR}/dist"
          # Try to validate zip first, then dmg
          ARCHIVE=$(find "$APP_DIST" -maxdepth 1 -type f \( -name '*.zip' -o -name '*.dmg' \) ! -name '*.blockmap' -print -quit || true)
          if [ -z "$ARCHIVE" ]; then
            echo 'No archive artifact found to validate' >&2
            exit 1
          fi
          EXTRACT_DIR="$(mktemp -d)"
          if [[ "$ARCHIVE" == *.zip ]]; then
            ditto -x -k "$ARCHIVE" "$EXTRACT_DIR"
          else
            # For DMG, mount and copy
            hdiutil attach "$ARCHIVE" -mountpoint "$EXTRACT_DIR/mnt" -nobrowse
            cp -R "$EXTRACT_DIR/mnt"/*.app "$EXTRACT_DIR/" 2>/dev/null || true
            hdiutil detach "$EXTRACT_DIR/mnt"
          fi
          APP_PATH=$(find "$EXTRACT_DIR" -maxdepth 2 -type d -name '*.app' -print -quit || true)
          if [ -z "$APP_PATH" ]; then
            echo 'Unable to locate .app bundle within archive' >&2
            exit 1
          fi
          xcrun stapler validate "$APP_PATH"
          spctl --assess --type exec -vv "$APP_PATH"

      - name: Upload macOS arm64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-arm64
          path: release

      - name: Clean up signing keychain
        if: always()
        shell: bash
        run: |
          if [ -n "${KEYCHAIN_NAME:-}" ]; then
            security delete-keychain "${KEYCHAIN_NAME}" || true
          fi

  # ============================================
  # macOS x64 Build (Intel)
  # ============================================
  macos-x64:
    needs: prepare
    runs-on: macos-15-intel
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
      CSC_FOR_PULL_REQUEST: 'true'
      CSC_LINK_BASE64: ${{ secrets.CSC_LINK_BASE64 }}
      CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Configure code signing keychain
        shell: bash
        run: |
          set -euxo pipefail
          if [ -z "${CSC_LINK_BASE64}" ]; then
            echo 'CSC_LINK_BASE64 secret is required for code signing' >&2
            exit 1
          fi
          if [ -z "${CSC_KEY_PASSWORD}" ]; then
            echo 'CSC_KEY_PASSWORD secret is required for code signing' >&2
            exit 1
          fi
          CERT_PATH="$RUNNER_TEMP/windword-developer-id.p12"
          KEYCHAIN_NAME="windword-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"
          echo "::add-mask::${KEYCHAIN_PASSWORD}"
          echo "${CSC_LINK_BASE64}" | base64 --decode > "${CERT_PATH}"
          security delete-keychain "${KEYCHAIN_NAME}" 2>/dev/null || true
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security set-keychain-settings "${KEYCHAIN_NAME}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          security import "${CERT_PATH}" -k "${KEYCHAIN_NAME}" -P "${CSC_KEY_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/productsign
          existing_keychains=$(security list-keychains -d user | sed 's/\"//g')
          security list-keychains -d user -s "${KEYCHAIN_NAME}" ${existing_keychains}
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_NAME}"
          echo "CSC_LINK=${CERT_PATH}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_NAME=${KEYCHAIN_NAME}" >> "${GITHUB_ENV}"
          echo "KEYCHAIN_PASSWORD=${KEYCHAIN_PASSWORD}" >> "${GITHUB_ENV}"

      - name: Inspect code signing identities
        shell: bash
        run: |
          set -euxo pipefail
          security find-identity -v -p codesigning "${KEYCHAIN_NAME}" || true

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install setuptools for node-gyp
        shell: bash
        run: pip3 install setuptools --break-system-packages

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile --config.store-dir=${{ env.PNPM_STORE_PATH }}

      - name: Build Apple Audio Mute CLI
        shell: bash
        run: pnpm build:apple-audio-mute-cli

      - name: Build Apple Audio Device CLI
        shell: bash
        run: pnpm build:apple-audio-device-cli

      - name: Build Apple Selection Detector CLI
        shell: bash
        run: pnpm build:apple-selection-detector-cli

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Verify notarization environment
        shell: bash
        run: |
          set -euo pipefail
          missing=0
          for var in APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID; do
            if [ -z "${!var:-}" ]; then
              echo "::error::${var} is empty"
              missing=1
            else
              echo "${var} is set"
            fi
          done
          if [ "$missing" -ne 0 ]; then exit 1; fi

      - name: Package artifacts
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: 'true'
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --mac --x64 --publish never
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          zip=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.zip' ! -name '*.blockmap' -print -quit || true)
          if [ -z "$zip" ]; then
            echo 'No zip artifact produced by electron-builder' >&2
            exit 1
          fi
          cp "$zip" "release/$(basename "$zip")"
          # Include metadata files
          if [ -f "$APP_DIST/latest-mac.yml" ]; then
            cp "$APP_DIST/latest-mac.yml" "release/latest-mac.yml"
          fi
          # Copy DMG and blockmap files
          find "$APP_DIST" -maxdepth 1 -type f -name '*.dmg' -exec cp {} release/ \;
          find "$APP_DIST" -maxdepth 1 -type f -name '*.blockmap' -exec cp {} release/ \;

      - name: Validate notarization
        shell: bash
        run: |
          set -euxo pipefail
          APP_DIST="${APP_DIR}/dist"
          # Try to validate zip first, then dmg
          ARCHIVE=$(find "$APP_DIST" -maxdepth 1 -type f \( -name '*.zip' -o -name '*.dmg' \) ! -name '*.blockmap' -print -quit || true)
          if [ -z "$ARCHIVE" ]; then
            echo 'No archive artifact found to validate' >&2
            exit 1
          fi
          EXTRACT_DIR="$(mktemp -d)"
          if [[ "$ARCHIVE" == *.zip ]]; then
            ditto -x -k "$ARCHIVE" "$EXTRACT_DIR"
          else
            # For DMG, mount and copy
            hdiutil attach "$ARCHIVE" -mountpoint "$EXTRACT_DIR/mnt" -nobrowse
            cp -R "$EXTRACT_DIR/mnt"/*.app "$EXTRACT_DIR/" 2>/dev/null || true
            hdiutil detach "$EXTRACT_DIR/mnt"
          fi
          APP_PATH=$(find "$EXTRACT_DIR" -maxdepth 2 -type d -name '*.app' -print -quit || true)
          if [ -z "$APP_PATH" ]; then
            echo 'Unable to locate .app bundle within archive' >&2
            exit 1
          fi
          xcrun stapler validate "$APP_PATH"
          spctl --assess --type exec -vv "$APP_PATH"

      - name: Upload macOS x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-x64
          path: release

      - name: Clean up signing keychain
        if: always()
        shell: bash
        run: |
          if [ -n "${KEYCHAIN_NAME:-}" ]; then
            security delete-keychain "${KEYCHAIN_NAME}" || true
          fi

  # ============================================
  # Windows x64 Build
  # ============================================
  windows-x64:
    needs: prepare
    runs-on: windows-latest
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Install NSIS
        shell: pwsh
        run: choco install nsis -y

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure pnpm for shorter paths
        shell: bash
        run: pnpm config set virtual-store-dir-max-length 70

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Package artifacts
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --win nsis --x64 --publish never
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          installer=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.exe' -print -quit || true)
          if [ -z "$installer" ]; then
            echo 'No Windows installer produced by electron-builder' >&2
            exit 1
          fi
          cp "$installer" "release/$(basename "$installer")"
          # Include metadata files
          if [ -f "$APP_DIST/latest.yml" ]; then
            cp "$APP_DIST/latest.yml" "release/latest.yml"
          fi
          find "$APP_DIST" -maxdepth 1 -type f -name '*.blockmap' -exec cp {} release/ \;

      - name: Upload Windows x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-x64
          path: release

  # ============================================
  # Linux x64 Build
  # ============================================
  linux-x64:
    needs: prepare
    runs-on: ubuntu-latest
    env:
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      OVERRIDE_VERSION: ${{ needs.prepare.outputs.semver }}
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          repository: feiandxs/windword
          token: ${{ secrets.PRIVATE_REPO_PAT }}
          ref: ${{ env.TAG_NAME }}

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Override package version
        shell: bash
        run: |
          set -euxo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.OVERRIDE_VERSION;
          if (!version) process.exit(0);
          const pkgPath = path.join(process.cwd(), process.env.APP_DIR, 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --version
          pnpm install --frozen-lockfile

      - name: Build project
        shell: bash
        run: pnpm --filter @windword/desktop build

      - name: Package artifacts
        shell: bash
        run: |
          set -euxo pipefail
          pnpm --filter @windword/desktop exec electron-builder --linux --x64 --publish never
          mkdir -p release
          APP_DIST="${APP_DIR}/dist"
          appimage=$(find "$APP_DIST" -maxdepth 1 -type f -name '*.AppImage' -print -quit || true)
          if [ -z "$appimage" ]; then
            echo 'No AppImage produced by electron-builder' >&2
            exit 1
          fi
          cp "$appimage" "release/$(basename "$appimage")"
          # Include metadata files
          if [ -f "$APP_DIST/latest-linux.yml" ]; then
            cp "$APP_DIST/latest-linux.yml" "release/latest-linux.yml"
          fi

      - name: Upload Linux x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-x64
          path: release

  # ============================================
  # Create Release: 创建 GitHub Release
  # ============================================
  create-release:
    needs:
      - prepare
      - macos-arm64
      - macos-x64
      - windows-x64
      - linux-x64
    runs-on: ubuntu-latest
    env:
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Merge macOS yml files
        shell: bash
        run: |
          set -euxo pipefail
          ARM64_YML="artifacts/macos-arm64/latest-mac.yml"
          X64_YML="artifacts/macos-x64/latest-mac.yml"
          MERGED_YML="artifacts/latest-mac.yml"

          if [ -f "$ARM64_YML" ] && [ -f "$X64_YML" ]; then
            echo "Merging latest-mac.yml files..."

            VERSION=$(grep "^version:" "$ARM64_YML" | head -1)
            RELEASE_DATE=$(grep "^releaseDate:" "$ARM64_YML" | head -1)

            # 用 awk 提取 files 部分
            ARM64_FILES=$(awk '/^files:/{flag=1; next} /^[a-zA-Z]/ && flag{flag=0} flag' "$ARM64_YML")
            X64_FILES=$(awk '/^files:/{flag=1; next} /^[a-zA-Z]/ && flag{flag=0} flag' "$X64_YML")

            PATH_LINE=$(grep "^path:" "$ARM64_YML" | head -1)
            SHA512_LINE=$(grep "^sha512:" "$ARM64_YML" | head -1)

            # 逐行写入合并后的文件
            echo "$VERSION" > "$MERGED_YML"
            echo "files:" >> "$MERGED_YML"
            echo "$ARM64_FILES" >> "$MERGED_YML"
            echo "$X64_FILES" >> "$MERGED_YML"
            echo "$PATH_LINE" >> "$MERGED_YML"
            echo "$SHA512_LINE" >> "$MERGED_YML"
            echo "$RELEASE_DATE" >> "$MERGED_YML"

            echo "Merged latest-mac.yml:"
            cat "$MERGED_YML"

            # 删除原始的 yml 文件
            rm -f "$ARM64_YML" "$X64_YML"
          elif [ -f "$ARM64_YML" ]; then
            echo "Only arm64 yml found, moving to artifacts root"
            mv "$ARM64_YML" "$MERGED_YML"
          elif [ -f "$X64_YML" ]; then
            echo "Only x64 yml found, moving to artifacts root"
            mv "$X64_YML" "$MERGED_YML"
          fi

          # Windows 的 latest.yml 移动到 artifacts 根目录
          WIN_YML="artifacts/windows-x64/latest.yml"
          if [ -f "$WIN_YML" ]; then
            mv "$WIN_YML" "artifacts/latest.yml"
          fi

          # Linux 的 latest-linux.yml 移动到 artifacts 根目录
          LINUX_YML="artifacts/linux-x64/latest-linux.yml"
          if [ -f "$LINUX_YML" ]; then
            mv "$LINUX_YML" "artifacts/latest-linux.yml"
          fi

      - name: Prepare release assets
        id: assets
        shell: bash
        run: |
          set -euxo pipefail
          assets_file="release-assets.txt"

          # 收集根目录的 yml 文件（已合并）
          find artifacts -maxdepth 1 -type f -name '*.yml' -print > "$assets_file"

          # 收集所有子目录的其他文件（zip, exe, AppImage, blockmap 等）
          find artifacts -mindepth 2 -type f \( \
            -name '*.zip' -o \
            -name '*.dmg' -o \
            -name '*.exe' -o \
            -name '*.AppImage' -o \
            -name '*.blockmap' \
          \) -print >> "$assets_file"

          sort -o "$assets_file" "$assets_file"

          if [ ! -s "$assets_file" ]; then
            echo 'No eligible release assets were found' >&2
            exit 1
          fi

          cat "$assets_file"
          echo "assets_file=$assets_file" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        shell: bash
        run: |
          set -euxo pipefail
          RELEASE_TIME="$(date -u '+%Y-%m-%d %H:%M:%SZ')"
          cat > release-notes.md << EOF
          ## WindWord ${TAG_NAME}

          Released at: ${RELEASE_TIME}

          ### Downloads

          | Platform | Download |
          |----------|----------|
          | macOS (Apple Silicon) | ✅ |
          | macOS (Intel) | ✅ |
          | Windows (x64) | ✅ |
          | Linux (x64) | ✅ |
          EOF

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ASSETS_FILE: ${{ steps.assets.outputs.assets_file }}
        shell: bash
        run: |
          set -euxo pipefail

          assets=()
          while IFS= read -r asset; do
            assets+=("$asset")
          done < "${ASSETS_FILE}"

          # Delete existing release if exists
          if gh release view "${TAG_NAME}" --repo ${{ github.repository }} >/dev/null 2>&1; then
            gh release delete "${TAG_NAME}" --repo ${{ github.repository }} -y || true
          fi

          # Create new release
          gh release create "${TAG_NAME}" "${assets[@]}" \
            --repo ${{ github.repository }} \
            --title "WindWord ${TAG_NAME}" \
            --notes-file release-notes.md

  # ============================================
  # Upload to CDN: 上传到云存储
  # ============================================
  upload-to-cdn:
    needs:
      - prepare
      - create-release
    runs-on: ubuntu-latest
    env:
      TAG_NAME: ${{ needs.prepare.outputs.tag_name }}
    steps:
      - name: Download release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          mkdir -p artifacts
          gh release download "$TAG_NAME" --repo ${{ github.repository }} -D artifacts
          echo "Downloaded assets:"
          ls -la artifacts/

      - name: Install AWS CLI
        run: pip install awscli

      - name: Upload to Cloudflare R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
          R2_PREFIX: ${{ secrets.R2_PREFIX }}
        run: |
          set -euxo pipefail
          PREFIX="${R2_PREFIX:-releases}"
          DEST="s3://${R2_BUCKET}/${PREFIX}"

          echo "Uploading to Cloudflare R2: ${DEST}"
          for file in artifacts/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "Uploading $filename..."
              aws s3 cp "$file" "$DEST/$filename" --endpoint-url "$R2_ENDPOINT"
            fi
          done

          echo "Cloudflare R2 upload completed successfully"

      - name: Cleanup old R2 versions (keep latest 5)
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
          R2_PREFIX: ${{ secrets.R2_PREFIX }}
        run: |
          set -euxo pipefail
          PREFIX="${R2_PREFIX:-releases}"
          KEEP_VERSIONS=5
          # Set to "true" for testing (shows what would be deleted without deleting)
          DRY_RUN="true"

          echo "=== R2 Retention Policy: Keep latest ${KEEP_VERSIONS} versions ==="
          if [ "$DRY_RUN" = "true" ]; then
            echo "*** DRY RUN MODE - No files will be deleted ***"
          fi

          # List all objects and extract unique versions
          # Supports both stable (1.2.3) and pre-release (1.2.3-beta.1) versions
          VERSIONS=$(aws s3 ls "s3://${R2_BUCKET}/${PREFIX}/" --endpoint-url "$R2_ENDPOINT" | \
            grep -oE 'WindWord-[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?' | \
            sed 's/WindWord-//' | \
            sort -u | \
            sort -t. -k1,1n -k2,2n -k3,3n)

          if [ -z "$VERSIONS" ]; then
            echo "No versions found in R2, skipping cleanup"
            exit 0
          fi

          VERSION_COUNT=$(echo "$VERSIONS" | wc -l | tr -d ' ')
          echo "Found $VERSION_COUNT unique versions in R2:"
          echo "$VERSIONS"

          if [ "$VERSION_COUNT" -le "$KEEP_VERSIONS" ]; then
            echo "No cleanup needed (${VERSION_COUNT} <= ${KEEP_VERSIONS})"
            exit 0
          fi

          # Get versions to delete (all except the last KEEP_VERSIONS)
          DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))
          VERSIONS_TO_DELETE=$(echo "$VERSIONS" | head -n "$DELETE_COUNT")

          echo ""
          echo "Versions to delete ($DELETE_COUNT):"
          echo "$VERSIONS_TO_DELETE"
          echo ""

          for VERSION in $VERSIONS_TO_DELETE; do
            echo "Deleting files for version ${VERSION}..."

            if [ "$DRY_RUN" = "true" ]; then
              # Dry run: just show what would be deleted
              aws s3 rm "s3://${R2_BUCKET}/${PREFIX}/" \
                --endpoint-url "$R2_ENDPOINT" \
                --recursive \
                --exclude "*" \
                --include "*-${VERSION}-*" \
                --include "*-${VERSION}.*" \
                --dryrun
            else
              # Actual deletion
              aws s3 rm "s3://${R2_BUCKET}/${PREFIX}/" \
                --endpoint-url "$R2_ENDPOINT" \
                --recursive \
                --exclude "*" \
                --include "*-${VERSION}-*" \
                --include "*-${VERSION}.*"
            fi
          done

          echo "=== Cleanup complete ==="

  # ============================================
  # Cleanup: 清理 artifacts
  # ============================================
  cleanup:
    needs:
      - create-release
      - upload-to-cdn
    if: always() && needs.create-release.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Clean up artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euxo pipefail
          echo "Cleaning up artifacts from this run..."
          for id in $(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --jq '.artifacts[].id'); do
            echo "Deleting artifact $id..."
            gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$id || true
          done
          echo "Artifacts cleaned up"
